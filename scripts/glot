#!/usr/bin/env python3

# This file is part of the Go-Smart Simulation Architecture (GSSA).
# Go-Smart is an EU-FP7 project, funded by the European Commission.
#
# Copyright (C) 2013-  NUMA Engineering Ltd. (see AUTHORS file)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


import click
import logging
import asyncio
from aiohttp import web
import os
import tarfile
from git import Repo
import shutil

from glot.connector import execute

_default_server_port = 18103


logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)


_repo_locations = {
    'goosefoot': 'https://github.com/go-smart/glossia-container-goosefoot-control'
}


@asyncio.coroutine
def start_one_file_http_server(filename):
    fut = asyncio.Future()

    def receive(request):
        logging.info('Got request')
        yield from request.post()
        try:
            with open(filename, 'wb') as f:
                g = request.POST['file'].file
                f.write(g.read())
            fut.set_result(filename)
        except:
            logging.exception('Could not receive file')
            fut.set_result(None)

        return web.Response(body=b"Accepted")

    app = web.Application()
    logging.info('Adding POST route at /receive')
    app.router.add_route('POST', '/receive', receive)

    loop = asyncio.get_event_loop()

    # FIXME: this should be tied to the Docker interface,
    # when we have a good way of calculating it
    srv = yield from loop.create_server(app.make_handler(), '0.0.0.0', 18103)

    return srv, fut


def execute_command(f):
    def run(ctx, **kwargs):
        logging.info("Executing command")

        kwargs['ctx'] = ctx
        execute(
            f,
            *ctx.obj['SERVER'],
            **kwargs
        )

        logging.info("[done]")
    run.__name__ = f.__name__
    return run


@click.group()
@click.option('--server', default=None, help='ID of the specific Glossia server (defaults to primary on router)')
@click.option('--router', default='localhost', help='location of the WAMP server')
@click.option('--port', default=8080, help='port on server for WebSocket connection')
@click.option('--to', default=None, help='name of destination folder')
@click.pass_context
def cli(ctx, server, router, port, to):
    """Manage Glossia from the CLI"""
    ctx.obj['SERVER'] = (server, router, port)
    ctx.obj['DESTINATION'] = to


@cli.command()
@click.argument('guid')
@click.pass_context
@execute_command
@asyncio.coroutine
def search(mc, guid, ctx):
    """Check for definitions match GUID (prefix)"""

    definitions = yield from mc('search', guid.upper())

    for g, d in definitions.items():
        print(g, d)


@cli.command()
@click.option('--target', default=None)
@click.option('-d', '--include-diagnostic', default=False, is_flag=True)
@click.argument('guid')
@click.pass_context
@execute_command
@asyncio.coroutine
def results(mc, guid, target, include_diagnostic, ctx):
    """Push results data to the webserver"""

    filename = None

    if target is None:
        logging.warn(
            "No target given, assuming we should provide "
            "a target for a local Glossia"
        )
        srv, fut = yield from start_one_file_http_server('%s-results.tgz' % guid)
    else:
        fut = None

    yield from mc('request_results', guid.upper(), target)

    if fut is not None:
        filename = yield from fut
        print(filename)
        srv.close()

    to = ctx.obj['DESTINATION'] if not target else None
    if to:
        os.makedirs(to, exist_ok=True)
        with tarfile.open(filename) as f:
            f.extractall(path=to)

    if include_diagnostic:
        yield from _diagnostic(mc, guid, target, False, ctx)


@cli.command()
@click.option('--target', default=None)
@click.option('--inspect', is_flag=True)
@click.argument('guid')
@click.pass_context
@execute_command
@asyncio.coroutine
def diagnostic(mc, guid, target, inspect, ctx):
    """Push diagnostic data to the webserver"""

    yield from _diagnostic(mc, guid, target, inspect, ctx)


def _diagnostic(mc, guid, target, inspect, ctx):
    filename = None

    if target is None:
        logging.warn(
            "No target given, assuming we should provide "
            "a target for a local Glossia"
        )
        srv, fut = yield from start_one_file_http_server('%s-diagnostic.tgz' % guid)
    else:
        fut = None

    files = yield from mc('request_diagnostic', guid.upper(), target)

    if fut is not None:
        filename = yield from fut
        print(filename)
        srv.close()

    to = ctx.obj['DESTINATION'] if not target else None
    if to:
        os.makedirs(to, exist_ok=True)
        with tarfile.open(filename) as f:
            f.extractall(path=to)

    if inspect:
        if filename is None:
            if len(files) < 1:
                raise RuntimeError("No diagnostic files returned")
            elif len(files) > 1:
                raise RuntimeError("Multiple diagnostic files, run inspect manually")

            filename = files.items()[0]
        inspect(filename)

    return filename


@cli.command()
@click.option('--force', is_flag=True)
@click.option('--mode', default='goosefoot')
@click.option('--verbose', is_flag=True)
@click.argument('archive')
def inspect(archive, force=False, mode='goosefoot', verbose=False):
    """Examine a diagnostic bundle"""

    if not os.path.exists(archive):
        raise RuntimeError("You must supply a diagnostic archive")

    path = os.path.splitext(archive)[0]
    rootpath = path

    if not force:
        if os.path.exists(path):
            raise FileExistsError("Run with --force to remove existing diagnostic directory")
    else:
        try:
            shutil.rmtree(path)
        except FileNotFoundError:
            pass

    logging.info("Extracting to {path}".format(path=path))

    repo_location = _repo_locations[mode]
    logging.info("Cloning control from {loc}".format(loc=repo_location))
    Repo.clone_from(repo_location, path)

    logging.info("Opening diagnostic archive {arc}".format(arc=archive))
    with tarfile.open(archive, 'r') as t:
        members = t.getmembers()
        names = [m.name for m in members if not m.isdir()]
        prefix = os.path.commonprefix(names)
        logging.info("Stripping prefix {prefix}".format(prefix=prefix))

        inp = os.path.join(prefix, 'input')
        try:
            t.getmember(inp)
        except KeyError:
            path = os.path.join(path, 'input')
            os.makedirs(path)

        for m in members:
            if m.name.startswith(prefix):
                outpath = os.path.join(path, m.name[len(prefix):])
                outpath = outpath.replace('input.final', 'input')

                if verbose:
                    logging.info("{fm} --> {to}".format(fm=m.name, to=outpath))

                if m.isdir():
                    os.makedirs(outpath)
                else:
                    with open(outpath, 'wb') as f, t.extractfile(m) as g:
                        shutil.copyfileobj(g, f)

    logging.info("Done extracting")

    if mode is 'goosefoot':
        shutil.copyfile(
            os.path.join(rootpath, 'input', 'settings.xml'),
            os.path.join(rootpath, 'settings', 'settings.xml')
        )


if __name__ == '__main__':
    cli(obj={})
